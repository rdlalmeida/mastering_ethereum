{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AggregatorInterface} from \"./AggregatorInterface.sol\";\nimport {AggregatorV3Interface} from \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../shared/interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 public constant override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(uint8 _decimals, int256 _initialAnswer) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(int256 _answer) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"v0.8/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "// Pragma\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n// Imports\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport {PriceConverter} from \"./PriceConverter.sol\";\n\n// Error Codes\n\n/// @notice Custom error for whenever anyone other than the contract owner tries to take ownership of the resource\nerror FundMe__NotOwner();\n\n/**\n    @notice Custom error for when a call to the FundMe.fund() function is placed with insufficient funds.\n    @param ethProvided The initial amount provided in the call\n    @param minEth The minimum value expected\n*/\nerror FundMe__NotEnoughETH(uint256 ethProvided, uint256 minEth);\n\n/// @notice Custom error for when a FundMe.withdraw call fails\nerror FundMe__CallFailed();\n\n/// @notice Test custom error\nerror FundMe__NonExistentFunction();\n\n// Interfaces\n\n// Libraries\n\n// Contracts\n/**\n    @title A contract for crowd funding\n    @author Ricardo Almeida\n    @notice This contract is to demo a sample funding contract\n    @dev This implements price feeds as our library\n*/\ncontract FundMe {\n    // Type Declarations\n    // This is the statement that allows line 25, where the \"getConversionRate\" function is called from a uint256 value (msg.value)\n    using PriceConverter for uint256;\n\n    // State Variables\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public founders;\n    // Could we make this constant? No! We should make it immutable!\n    address public immutable OWNER;\n    // Minimum ETH to send, as USD\n    uint256 public constant MINIMUM_USD = 5 * 10 ** 18; // 50 * 10 ** 18 = 50e18 = 50000000000000000000;\n    AggregatorV3Interface public priceFeed;\n\n    // Events\n\n    // Modifiers\n    modifier onlyOwner() {\n        // NOTE: NotOwner is a custom error defined at the top of this module.\n        if (msg.sender != OWNER) revert FundMe__NotOwner();\n        _;\n    }\n\n    // Functions Order:\n    // constructor\n    // receive\n    // fallback\n    // external\n    // public\n    // internal\n    // private\n    // view/pure\n\n    constructor(address priceFeedAddress) {\n        OWNER = msg.sender;\n        priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    /**\n        @notice This function funds this contract\n        @dev This implements price feed as our library\n    */\n    function fund() public payable {\n        /*\n            This one is particularly messy, even in Javascript terms...\n            So, the 'getConversionRate' function is obtained from the PriceConverter.sol module. Normal, decent programming\n            languages typically specify this somewhere, but not Javascript! Oh no, with fucking Javascript you have to 'guess'\n            it, you need divination skills to work with this shit...\n            So, is this it? Is this the whole spectrum of messiness you're talking about??\n            Fuck no! This is just an apetizer!\n            \n            Next comes the weirdest thing I ever saw as a software engineer:\n            So, 'getConversionRate' takes two arguments: a uint256 amount and an AggregatorV3Interface object named priceFeed. So far so good\n            But, by some stupid reason, the first argument is 'passed' by... (I need to breathe deeply first) calling the function from\n            the argument.. HOW IS THIS LOGIC????? WHO THE FUCK CAME UP WITH THIS STUPIDITY???? THIS GOES AGAINST EVERY SINGLE NOTION\n            OF GOOD SOFTWARE WRITTING!\n            So, not only you have to find out where the fuck the 'getConversionRate' comes from, but you also have to take into account\n            that, UNLINKE EVERY DECENT AND LOGIC PROGRAMMING LANGUAGE OUT THERE (including fucking PhP!!!!!), you can invoke a function\n            from a non-object, like an uint256, and when you do, the first argument (but not the second or any other after) is actually\n            actually that value??? This is madness I tell you...\n            OK, confusing enough... But what if the function has more than one input?\n            Well, if that is the case, Javascript simply becomes exponentially more stupid to solve that! How do you provide the second argument???\n            By doing it as if it was the first, i.e., inside parethesis...\n            But what about the first argument? Should it also go inside the parenthesis as well?\n            One would assume so, if the rules of logic and decency where applicable in this bullshit of a programming language, but no,\n            apparently one can pass two arguments to one function as such:\n\n            msg.value.getConversionRate(priceFeed)\n\n            So, just to sum up this mess:\n                · getConversionRate is a function from the PriceConverter.sol contract. In a normal programming language, you would\n                invoke it like:\n                    \n                    var answer = PriceConverter.getConversionRate(arg1, arg2);\n                \n                But in fucking Javascript, its whatever...\n\n            · msg.value is actually arg1, which if you look at the function signature, it has to be a uint256 value. The weird\n            thing is that you can invoke the function from addressing the input argument! There must be 2 situations in the whole\n            wide world where this approach was actually efficient, but that is enough to make this a valid call in fucking Javascript\n\n            · priceFeed is arg2 and the only 'normal' thing in this bullshit, if you ignore the fact that arg2 is passed as arg1...\n\n            Uff.. that's about it. I need these cathartic notes here and there because working with Javascript is often a mystery.\n        */\n        uint256 ethProvided = msg.value.getConversionRate(priceFeed);\n\n        if (ethProvided <= MINIMUM_USD) {\n            revert FundMe__NotEnoughETH(ethProvided, MINIMUM_USD);\n        }\n\n        addressToAmountFunded[msg.sender] += msg.value;\n        founders.push(msg.sender);\n    }\n\n    /**\n        @notice This function returns the version of the price feed service.\n        @return uint256 The version of the price feed service in use\n    */\n    function getVersion() public view returns (uint256) {\n        // ETH/USD price feed address of Sepolia Network\n        return priceFeed.version();\n    }\n\n    /**\n        @notice This function withdraws all the funds set so far into the owner's account.\n    */\n    function withdraw() public onlyOwner {\n        // Go through all the founders so far\n        for (\n            uint256 founderIndex = 0;\n            founderIndex < founders.length;\n            founderIndex++\n        ) {\n            // And one by one, extract the address of a founder\n            address founder = founders[founderIndex];\n\n            // And set all the funds sent so far to 0\n            addressToAmountFunded[founder] = 0;\n        }\n\n        // Reset the array of founders\n        founders = new address[](0);\n\n        /* \n            Apparentely there are several ways to achieve the next objective, namely, to send all the funds from the individual\n            founders to this contract. This is the \"older\" version using a delegated call (I think...)\n\n            payable(msg.sender).transfer(address(this).balance);\n\n            bool sendSuccess = payable(msg.sender).send(address(this).balance);\n            require(sendSuccess, \"Send failed\");\n\n            call\n        */\n\n        // This version is more \"secure\", apparentely...\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n\n        if (!callSuccess) {\n            revert FundMe__CallFailed();\n        }\n    }\n\n    /**\n        @notice Standard fallback function to be executed when no other path is available for the smart contract execution.\n    */\n    fallback() external payable {\n        fund();\n    }\n\n    /**\n        @notice Standard receive function to be used as it is indicated.\n    */\n    receive() external payable {\n        fund();\n    }\n}\n"
    },
    "contracts/FundMeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n    This contract serves simply to create a contract without a proper receive function and thus use it to trigger\n    a call failure, so that I can properly test the rest of the other contracts\n*/\npragma solidity ^0.8.24;\n\nerror FundMeHelper__InvalidFunds(uint256 fundProvided, uint256 minimumFunds);\nimport {FundMe} from \"./FundMe.sol\";\n\ncontract FundMeHelper {\n    uint256 public constant MINIMUM_ETH = 5 * 10 ** 17; // I'm setting the minimum amount to fund to 0.5 ETH\n    FundMe public fundMeContract;\n\n    constructor(address priceFeedAddress) {\n        fundMeContract = new FundMe(priceFeedAddress);\n    }\n\n    function initialFund() public payable {\n        if (msg.value <= MINIMUM_ETH) {\n            revert FundMeHelper__InvalidFunds(msg.value, MINIMUM_ETH);\n        }\n    }\n\n    // Create a withdraw function for this contract that simply calls the same function in the main contract. But since this one\n    // does not have a corresponding receive function, calling this withdraw should always trigger the custom error associated\n    // from the main contract\n    function helperWithdraw() external {\n        /* \n            The idea with this function is to use it as a \"delegate call\" for the main contract's withdraw function. Since this\n            contract does not have a 'receive' function (unlike the main one), the withdraw is going to transfer any funds from\n            the main contract to the one calling the function, which because of what I'm doing, is going to be this helper\n            contract (more aptly, the address to where this contract was deployed). Note that this contract CAN be funded using\n            the 'initialFund' function above (because it was set as 'payable'), but the withdraw function from the main contract\n            expects the existence of a 'receive' function that is also payable. This means that this error actually can be \n            triggered by a number of ways:\n            · setting a 'receive' function but not setting it to be payable\n            · setting a payable function called 'receiving', for example\n\n            But for this case I'm simply omiting the receive function and that's it.  \n        */\n        fundMeContract.withdraw();\n    }\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n// import {FundMe} from \"./FundMe.sol\";\n\nlibrary PriceConverter {\n    // We could make this public, but then we'd have to deploy it\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        // Sepolia ETH / USD Address\n\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        // ETH/USD rate in 18 digit\n\n        return uint256(answer * 1e10); // 1e10 = 10000000000\n    }\n\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // 1e18 = 1000000000000000000\n\n        return ethAmountInUsd;\n    }\n}\n"
    },
    "contracts/test/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol\";\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}