{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n    // This is the statement that allows line 25, where the \"getConversionRate\" function is called from a uint256 value (msg.value)\n    using PriceConverter for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    // Could we make this constant? No! We should make it immutable!\n    address public immutable owner;\n    uint256 public constant MINIMUM_USD = 50 * 10 ** 18; // 50 * 10 ** 18 = 50e18 = 50000000000000000000;\n\n    AggregatorV3Interface public priceFeed;\n\n    constructor(address PriceFeedAddress) {\n        owner = msg.sender;\n        priceFeed = AggregatorV3Interface(PriceFeedAddress);\n    }\n\n    function fund() public payable {\n        require(\n            /*\n                This one is particularly messy, even in Javascript terms...\n                So, the 'getConversionRate' function is obtained from the PriceConverter.sol module. Normal, decent programming\n                languages typically specify this somewhere, but not Javascript! Oh no, with fucking Javascript you have to 'guess'\n                it, you need divination skills to work with this shit...\n                So, is this it? Is this the whole spectrum of messiness you're talking about??\n                Fuck no! This is just an apetizer!\n                \n                Next comes the weirdest thing I ever saw as a software engineer:\n                So, 'getConversionRate' takes two arguments: a uint256 amount and an AggregatorV3Interface object named priceFeed. So far so good\n                But, by some stupid reason, the first argument is 'passed' by... (I need to breathe deeply first) calling the function from\n                the argument.. HOW IS THIS LOGIC????? WHO THE FUCK CAME UP WITH THIS STUPIDITY???? THIS GOES AGAINST EVERY SINGLE NOTION\n                OF GOOD SOFTWARE WRITTING!\n                So, not only you have to find out where the fuck the 'getConversionRate' comes from, but you also have to take into account\n                that, UNLINKE EVERY DECENT AND LOGIC PROGRAMMING LANGUAGE OUT THERE (including fucking PhP!!!!!), you can invoke a function\n                from a non-object, like an uint256, and when you do, the first argument (but not the second or any other after) is actually\n                actually that value??? This is madness I tell you...\n                OK, confusing enough... But what if the function has more than one input?\n                Well, if that is the case, Javascript simply becomes exponentially more stupid to solve that! How do you provide the second argument???\n                By doing it as if it was the first, i.e., inside parethesis...\n                But what about the first argument? Should it also go inside the parenthesis as well?\n                One would assume so, if the rules of logic and decency where applicable in this bullshit of a programming language, but no,\n                apparently one can pass two arguments to one function as such:\n\n                msg.value.getConversionRate(priceFeed)\n\n                So, just to sum up this mess:\n                    · getConversionRate is a function from the PriceConverter.sol contract. In a normal programming language, you would\n                    invoke it like:\n                        '\n                            import \"./PriceConverter.sol\"\n\n                            var answer = PriceConverter.getConversionRate(arg1, arg2);\n                        '\n                    But in fucking Javascript, its whatever...\n\n                · msg.value is actually arg1, which if you look at the function signature, it has to be a uint256 value. The weird\n                thing is that you can invoke the function from addressing the input argument! There must be 2 situations in the whole\n                wide world where this approach was actually efficient, but that is enough to make this a valid call in fucking Javascript\n\n                · priceFeed is arg2 and the only 'normal' thing in this bullshit, if you ignore the fact that arg2 is passed as arg1...\n\n                Uff.. that's about it. I need these cathartic notes here and there because working with Javascript is often a mystery.\n            */\n            msg.value.getConversionRate(priceFeed) >= MINIMUM_USD,\n            \"You need to spend more ETH!\"\n        );\n        addressToAmountFunded[msg.sender] += msg.value;\n        funders.push(msg.sender);\n    }\n\n    function getVersion() public view returns (uint256) {\n        // ETH/USD price feed address of Sepolia Network\n        return priceFeed.version();\n    }\n\n    modifier onlyOwner() {\n        // NOTE: NotOwner is a custom error defined at the top of this module.\n        if (msg.sender != owner) revert NotOwner();\n        _;\n    }\n\n    function withdraw() public onlyOwner {\n        // Go through all the funders so far\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            // And one by one, extract the address of a funder\n            address funder = funders[funderIndex];\n\n            // And set all the funds sent so far to 0\n            addressToAmountFunded[funder] = 0;\n        }\n\n        // Reset the array of funders\n        funders = new address[](0);\n\n        /* \n            Apparentely there are several ways to achieve the next objective, namely, to send all the funds from the individual\n            funders to this contract. This is the \"older\" version using a delegated call (I think...)\n\n            payable(msg.sender).transfer(address(this).balance);\n\n            bool sendSuccess = payable(msg.sender).send(address(this).balance);\n            require(sendSuccess, \"Send failed\");\n\n            call\n        */\n\n        // This version is more \"secure\", apparentely...\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    fallback() external payable {\n        fund();\n    }\n\n    receive() external payable {\n        fund();\n    }\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport \"./FundMe.sol\";\n\nlibrary PriceConverter {\n    // We could make this public, but then we'd have to deploy it\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        // Sepolia ETH / USD Address\n\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        // ETH/USD rate in 18 digit\n\n        return uint256(answer * 1e10); // 1e10 = 10000000000\n    }\n\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // 1e18 = 1000000000000000000\n\n        return ethAmountInUsd;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}